import { config } from "../data/config.js";

export function initPuzzle() {
  // Don't render if disabled in config
  if (!config.puzzle?.enabled) return;

  const section = document.getElementById("puzzle");
  const gridSize = config.puzzle.gridSize || 3;

  // Render HTML structure
  section.innerHTML = `
    <h2 class="section__title section__title--light" data-reveal>
      ${config.puzzle.title}
    </h2>

    <div class="puzzle__container" data-reveal>
      <div class="puzzle__mode-switcher">
        <button class="puzzle__mode-btn" data-mode="easy">Easy</button>
        <button class="puzzle__mode-btn" data-mode="hard">Hard</button>
      </div>

      <div class="puzzle__board" data-grid-size="${gridSize}">
        <!-- Tiles generated by JS -->
      </div>

      <div class="puzzle__controls">
        <div class="puzzle__stats">
          <span class="puzzle__stat">
            <span class="puzzle__stat-label">Moves:</span>
            <span class="puzzle__stat-value" id="move-count">0</span>
          </span>
        </div>

        <div class="puzzle__direction-pad" id="direction-pad" hidden>
          <button class="puzzle__direction-btn puzzle__direction-btn--up" data-direction="up" aria-label="Move up">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor">
              <path d="M18 15l-6-6-6 6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <div class="puzzle__direction-row">
            <button class="puzzle__direction-btn puzzle__direction-btn--left" data-direction="left" aria-label="Move left">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor">
                <path d="M15 18l-6-6 6-6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <button class="puzzle__direction-btn puzzle__direction-btn--right" data-direction="right" aria-label="Move right">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor">
                <path d="M9 18l6-6-6-6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
          </div>
          <button class="puzzle__direction-btn puzzle__direction-btn--down" data-direction="down" aria-label="Move down">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor">
              <path d="M6 9l6 6 6-6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>

        <button class="puzzle__reset-btn" id="puzzle-reset">
          <svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" fill="none">
            <path d="M1 4v6h6M23 20v-6h-6"></path>
            <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>
          </svg>
          Reset
        </button>
      </div>
    </div>

    <div class="puzzle__win" id="puzzle-win" hidden>
      <div class="puzzle__win-content">
        <div class="puzzle__win-icon">ðŸŽ‰</div>
        <p class="puzzle__win-message">${config.puzzle.winMessage}</p>
        <p class="puzzle__win-subtitle" id="puzzle-win-subtitle"></p>
      </div>
    </div>
  `;

  // Initialize game state and logic
  initGame();
}

function initGame() {
  const gridSize = config.puzzle.gridSize || 3;
  const totalTiles = gridSize * gridSize;

  // State (closure-based like countdown.js)
  let tiles = [];
  let emptyIndices = []; // Array of empty tile indices
  let moveCount = 0;
  let isWon = false;
  let mode = config.puzzle.defaultMode || "easy"; // "easy" or "hard"
  let selectedTileIndex = null; // Track selected tile for directional mode
  const directionalMode = config.puzzle?.directionalControls || "off";

  // Cache DOM elements
  const board = document.querySelector(".puzzle__board");
  const moveCountEl = document.getElementById("move-count");
  const resetBtn = document.getElementById("puzzle-reset");
  const winOverlay = document.getElementById("puzzle-win");
  const winSubtitleEl = document.getElementById("puzzle-win-subtitle");
  const modeButtons = document.querySelectorAll(".puzzle__mode-btn");

  // Generate initial solved state
  function createSolvedState() {
    return Array.from({ length: totalTiles }, (_, i) => i);
  }

  // Fisher-Yates shuffle
  function fisherYatesShuffle(arr) {
    const shuffled = [...arr];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  // Check if puzzle configuration is solvable
  function isSolvable(arr) {
    const filtered = arr.filter(n => n !== totalTiles - 1); // Exclude empty tile
    let inversions = 0;

    for (let i = 0; i < filtered.length; i++) {
      for (let j = i + 1; j < filtered.length; j++) {
        if (filtered[i] > filtered[j]) {
          inversions++;
        }
      }
    }

    if (gridSize % 2 === 1) {
      // Odd grid: inversions must be even
      return inversions % 2 === 0;
    } else {
      // Even grid: (inversions + empty row from bottom) must be odd
      const emptyRow = Math.floor(arr.indexOf(totalTiles - 1) / gridSize);
      const emptyRowFromBottom = gridSize - 1 - emptyRow;
      return (inversions + emptyRowFromBottom) % 2 === 1;
    }
  }

  // Shuffle with solvability check
  function shuffle(arr) {
    let shuffled;
    do {
      shuffled = fisherYatesShuffle(arr);
    } while (!isSolvable(shuffled));
    return shuffled;
  }

  // Check if puzzle is solved
  function checkWin() {
    if (mode === "easy") {
      // Easy mode: last 2 positions should contain last 2 tile values (in any order)
      const lastTwo = [totalTiles - 2, totalTiles - 1];
      const lastTwoPositions = [tiles[totalTiles - 2], tiles[totalTiles - 1]];
      return (
        lastTwoPositions.sort().toString() === lastTwo.toString() &&
        tiles.slice(0, totalTiles - 2).every((tile, index) => tile === index)
      );
    } else {
      // Hard mode: standard check
      return tiles.every((tile, index) => tile === index);
    }
  }

  // Get valid moves for a given tile index
  function getValidMoves(tileIndex) {
    const row = Math.floor(tileIndex / gridSize);
    const col = tileIndex % gridSize;
    const adjacent = [];

    if (row > 0) adjacent.push(tileIndex - gridSize); // Up
    if (row < gridSize - 1) adjacent.push(tileIndex + gridSize); // Down
    if (col > 0) adjacent.push(tileIndex - 1); // Left
    if (col < gridSize - 1) adjacent.push(tileIndex + 1); // Right

    // Check if any adjacent position is an empty tile
    return adjacent.filter(pos => emptyIndices.includes(pos));
  }

  // Get direction from tile to empty position
  function getDirection(fromIndex, toIndex) {
    if (toIndex === fromIndex - gridSize) return "up";
    if (toIndex === fromIndex + gridSize) return "down";
    if (toIndex === fromIndex - 1) return "left";
    if (toIndex === fromIndex + 1) return "right";
    return null;
  }

  // Get position from tile in given direction
  function getPositionInDirection(tileIndex, direction) {
    const row = Math.floor(tileIndex / gridSize);
    const col = tileIndex % gridSize;

    switch(direction) {
      case "up":
        return row > 0 ? tileIndex - gridSize : null;
      case "down":
        return row < gridSize - 1 ? tileIndex + gridSize : null;
      case "left":
        return col > 0 ? tileIndex - 1 : null;
      case "right":
        return col < gridSize - 1 ? tileIndex + 1 : null;
      default:
        return null;
    }
  }

  // Update directional button states
  function updateDirectionButtons() {
    if (directionalMode === "off") return;

    const directionPad = document.getElementById("direction-pad");
    const buttons = directionPad.querySelectorAll(".puzzle__direction-btn");

    if (selectedTileIndex === null) {
      // No tile selected - disable all buttons
      buttons.forEach(btn => {
        btn.disabled = true;
      });
      directionPad.hidden = true;
      return;
    }

    // Show direction pad
    directionPad.hidden = false;

    // Get valid moves for selected tile
    const validEmptyPositions = getValidMoves(selectedTileIndex);
    const validDirections = validEmptyPositions.map(pos =>
      getDirection(selectedTileIndex, pos)
    );

    // Enable/disable buttons based on valid moves
    buttons.forEach(btn => {
      const direction = btn.dataset.direction;
      btn.disabled = !validDirections.includes(direction);
    });
  }

  // Clear tile selection
  function clearSelection() {
    if (selectedTileIndex !== null) {
      const prevTile = board.querySelector(`[data-index="${selectedTileIndex}"]`);
      if (prevTile) {
        prevTile.classList.remove("puzzle__tile--selected");
      }
      selectedTileIndex = null;
      updateDirectionButtons();
    }
  }

  // Select a tile
  function selectTile(index) {
    // Don't allow selecting empty tiles
    const isEmpty = emptyIndices.includes(index);
    if (isEmpty) {
      clearSelection();
      return;
    }

    // Clear previous selection
    clearSelection();

    // Set new selection
    selectedTileIndex = index;
    const tile = board.querySelector(`[data-index="${index}"]`);
    if (tile) {
      tile.classList.add("puzzle__tile--selected");
    }

    updateDirectionButtons();
  }

  // Move selected tile in direction
  function moveInDirection(direction) {
    if (selectedTileIndex === null) return;

    const targetPos = getPositionInDirection(selectedTileIndex, direction);
    if (targetPos === null) return;

    // Check if target position is empty
    if (!emptyIndices.includes(targetPos)) return;

    // Perform the move
    [tiles[selectedTileIndex], tiles[targetPos]] = [tiles[targetPos], tiles[selectedTileIndex]];

    // Update emptyIndices array
    const emptyIndexInArray = emptyIndices.indexOf(targetPos);
    emptyIndices[emptyIndexInArray] = selectedTileIndex;

    moveCount++;

    // Clear selection
    clearSelection();

    // Update UI
    renderBoard();
    moveCountEl.textContent = moveCount;

    // Check win
    if (checkWin()) {
      handleWin();
    }
  }

  // Handle tile click
  function handleTileClick(index) {
    if (isWon) return;

    const isEmpty = emptyIndices.includes(index);

    // Hybrid or required mode
    if (directionalMode === "hybrid" || directionalMode === "required") {
      if (isEmpty) {
        // Clicking empty tile clears selection
        clearSelection();
        return;
      }

      const adjacentEmptyTiles = getValidMoves(index);

      if (adjacentEmptyTiles.length === 0) {
        // Invalid tile - shake and clear selection
        clearSelection();
        const tileEl = board.querySelector(`[data-index="${index}"]`);
        if (tileEl) {
          tileEl.classList.add("puzzle__tile--invalid");
          setTimeout(() => tileEl.classList.remove("puzzle__tile--invalid"), 300);
        }
        return;
      }

      // In hybrid mode, allow direct click if only one move available
      if (directionalMode === "hybrid" && adjacentEmptyTiles.length === 1) {
        const emptyPos = adjacentEmptyTiles[0];
        [tiles[index], tiles[emptyPos]] = [tiles[emptyPos], tiles[index]];

        const emptyIndexInArray = emptyIndices.indexOf(emptyPos);
        emptyIndices[emptyIndexInArray] = index;

        moveCount++;
        clearSelection();
        renderBoard();
        moveCountEl.textContent = moveCount;

        if (checkWin()) {
          handleWin();
        }
        return;
      }

      // Multiple moves available or required mode - select tile
      selectTile(index);
      return;
    }

    // Original behavior for "off" mode
    if (isEmpty) return;

    const adjacentEmptyTiles = getValidMoves(index);
    if (adjacentEmptyTiles.length === 0) {
      const tileEl = board.querySelector(`[data-index="${index}"]`);
      if (tileEl) {
        tileEl.classList.add("puzzle__tile--invalid");
        setTimeout(() => tileEl.classList.remove("puzzle__tile--invalid"), 300);
      }
      return;
    }

    // Auto-move to first valid direction
    const emptyPos = adjacentEmptyTiles[0];
    [tiles[index], tiles[emptyPos]] = [tiles[emptyPos], tiles[index]];

    const emptyIndexInArray = emptyIndices.indexOf(emptyPos);
    emptyIndices[emptyIndexInArray] = index;

    moveCount++;
    renderBoard();
    moveCountEl.textContent = moveCount;

    if (checkWin()) {
      handleWin();
    }
  }

  // Render board
  function renderBoard() {
    // Determine which tile values are empty based on mode
    const emptyValues = mode === "easy"
      ? [totalTiles - 2, totalTiles - 1]
      : [totalTiles - 1];

    board.innerHTML = tiles
      .map((tileValue, index) => {
        const isEmpty = emptyValues.includes(tileValue);
        const row = Math.floor(tileValue / gridSize);
        const col = tileValue % gridSize;

        // Calculate background position for image tiles
        const bgPosX = (col / (gridSize - 1)) * 100;
        const bgPosY = (row / (gridSize - 1)) * 100;

        const imageUrl = config.puzzle.image
          ? `${import.meta.env.BASE_URL}${config.puzzle.image.replace(/^\//, "")}`
          : "";

        const imageStyle =
          !isEmpty && imageUrl
            ? `background-image: url('${imageUrl}');
               background-position: ${bgPosX}% ${bgPosY}%;
               background-size: ${gridSize * 100}%;`
            : "";

        return `
        <div
          class="puzzle__tile ${isEmpty ? "puzzle__tile--empty" : ""}"
          data-index="${index}"
          data-value="${tileValue}"
          style="${imageStyle}"
        >
          ${!isEmpty && !config.puzzle.image ? tileValue + 1 : ""}
        </div>
      `;
      })
      .join("");

    // Add click listeners
    board.querySelectorAll(".puzzle__tile").forEach((tile, index) => {
      tile.addEventListener("click", () => handleTileClick(index));
    });
  }

  // Handle win state
  function handleWin() {
    isWon = true;

    // Update win message with move count and mode
    const modeText = mode === "easy" ? "easy" : "hard";
    winSubtitleEl.textContent = `You solved it in ${moveCount} moves on ${modeText} mode!`;

    // Show win overlay with delay for last tile animation
    setTimeout(() => {
      winOverlay.hidden = false;
      winOverlay.classList.add("puzzle__win--show");
    }, 300);
  }

  // Reset game
  function resetGame() {
    tiles = shuffle(createSolvedState());

    // Initialize empty indices based on mode
    if (mode === "easy") {
      emptyIndices = [
        tiles.indexOf(totalTiles - 2),
        tiles.indexOf(totalTiles - 1)
      ];
    } else {
      emptyIndices = [tiles.indexOf(totalTiles - 1)];
    }

    moveCount = 0;
    isWon = false;

    moveCountEl.textContent = "0";
    winOverlay.hidden = true;
    winOverlay.classList.remove("puzzle__win--show");

    clearSelection();
    updateModeButtons();
    renderBoard();
  }

  // Update mode button active states
  function updateModeButtons() {
    modeButtons.forEach(btn => {
      if (btn.dataset.mode === mode) {
        btn.classList.add("puzzle__mode-btn--active");
      } else {
        btn.classList.remove("puzzle__mode-btn--active");
      }
    });
  }

  // Handle mode switch
  function handleModeSwitch(newMode) {
    if (mode === newMode) return;
    mode = newMode;
    resetGame();
  }

  // Initialize
  resetBtn.addEventListener("click", resetGame);
  modeButtons.forEach(btn => {
    btn.addEventListener("click", () => handleModeSwitch(btn.dataset.mode));
  });

  // Direction button listeners
  if (directionalMode !== "off") {
    const directionButtons = document.querySelectorAll(".puzzle__direction-btn");
    directionButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        const direction = btn.dataset.direction;
        moveInDirection(direction);
      });
    });
  }

  resetGame();
}
