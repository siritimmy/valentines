import { config } from "../data/config.js";

export function initPuzzle() {
  // Don't render if disabled in config
  if (!config.puzzle?.enabled) return;

  const section = document.getElementById("puzzle");
  const gridSize = config.puzzle.gridSize || 3;

  // Render HTML structure
  section.innerHTML = `
    <h2 class="section__title section__title--light" data-reveal>
      ${config.puzzle.title}
    </h2>

    <div class="puzzle__container" data-reveal>
      <div class="puzzle__mode-switcher">
        <button class="puzzle__mode-btn" data-mode="easy">Easy</button>
        <button class="puzzle__mode-btn" data-mode="hard">Hard</button>
      </div>

      <div class="puzzle__board" data-grid-size="${gridSize}">
        <!-- Tiles generated by JS -->
      </div>

      <div class="puzzle__controls">
        <div class="puzzle__stats">
          <span class="puzzle__stat">
            <span class="puzzle__stat-label">Moves:</span>
            <span class="puzzle__stat-value" id="move-count">0</span>
          </span>
        </div>
        <button class="puzzle__reset-btn" id="puzzle-reset">
          <svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" fill="none">
            <path d="M1 4v6h6M23 20v-6h-6"></path>
            <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>
          </svg>
          Reset
        </button>
      </div>
    </div>

    <div class="puzzle__win" id="puzzle-win" hidden>
      <div class="puzzle__win-content">
        <div class="puzzle__win-icon">ðŸŽ‰</div>
        <p class="puzzle__win-message">${config.puzzle.winMessage}</p>
        <p class="puzzle__win-subtitle" id="puzzle-win-subtitle"></p>
      </div>
    </div>
  `;

  // Initialize game state and logic
  initGame();
}

function initGame() {
  const gridSize = config.puzzle.gridSize || 3;
  const totalTiles = gridSize * gridSize;

  // State (closure-based like countdown.js)
  let tiles = [];
  let emptyIndices = []; // Array of empty tile indices
  let moveCount = 0;
  let isWon = false;
  let mode = config.puzzle.defaultMode || "easy"; // "easy" or "hard"

  // Cache DOM elements
  const board = document.querySelector(".puzzle__board");
  const moveCountEl = document.getElementById("move-count");
  const resetBtn = document.getElementById("puzzle-reset");
  const winOverlay = document.getElementById("puzzle-win");
  const winSubtitleEl = document.getElementById("puzzle-win-subtitle");
  const modeButtons = document.querySelectorAll(".puzzle__mode-btn");

  // Generate initial solved state
  function createSolvedState() {
    return Array.from({ length: totalTiles }, (_, i) => i);
  }

  // Fisher-Yates shuffle
  function fisherYatesShuffle(arr) {
    const shuffled = [...arr];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  // Check if puzzle configuration is solvable
  function isSolvable(arr) {
    const filtered = arr.filter(n => n !== totalTiles - 1); // Exclude empty tile
    let inversions = 0;

    for (let i = 0; i < filtered.length; i++) {
      for (let j = i + 1; j < filtered.length; j++) {
        if (filtered[i] > filtered[j]) {
          inversions++;
        }
      }
    }

    if (gridSize % 2 === 1) {
      // Odd grid: inversions must be even
      return inversions % 2 === 0;
    } else {
      // Even grid: (inversions + empty row from bottom) must be odd
      const emptyRow = Math.floor(arr.indexOf(totalTiles - 1) / gridSize);
      const emptyRowFromBottom = gridSize - 1 - emptyRow;
      return (inversions + emptyRowFromBottom) % 2 === 1;
    }
  }

  // Shuffle with solvability check
  function shuffle(arr) {
    let shuffled;
    do {
      shuffled = fisherYatesShuffle(arr);
    } while (!isSolvable(shuffled));
    return shuffled;
  }

  // Check if puzzle is solved
  function checkWin() {
    if (mode === "easy") {
      // Easy mode: last 2 positions should contain last 2 tile values (in any order)
      const lastTwo = [totalTiles - 2, totalTiles - 1];
      const lastTwoPositions = [tiles[totalTiles - 2], tiles[totalTiles - 1]];
      return (
        lastTwoPositions.sort().toString() === lastTwo.toString() &&
        tiles.slice(0, totalTiles - 2).every((tile, index) => tile === index)
      );
    } else {
      // Hard mode: standard check
      return tiles.every((tile, index) => tile === index);
    }
  }

  // Get valid moves for a given tile index
  function getValidMoves(tileIndex) {
    const row = Math.floor(tileIndex / gridSize);
    const col = tileIndex % gridSize;
    const adjacent = [];

    if (row > 0) adjacent.push(tileIndex - gridSize); // Up
    if (row < gridSize - 1) adjacent.push(tileIndex + gridSize); // Down
    if (col > 0) adjacent.push(tileIndex - 1); // Left
    if (col < gridSize - 1) adjacent.push(tileIndex + 1); // Right

    // Check if any adjacent position is an empty tile
    return adjacent.filter(pos => emptyIndices.includes(pos));
  }

  // Handle tile click
  function handleTileClick(index) {
    if (isWon) return;

    const adjacentEmptyTiles = getValidMoves(index);
    if (adjacentEmptyTiles.length === 0) {
      // Invalid move - add shake animation
      const tileEl = board.querySelector(`[data-index="${index}"]`);
      if (tileEl) {
        tileEl.classList.add("puzzle__tile--invalid");
        setTimeout(() => tileEl.classList.remove("puzzle__tile--invalid"), 300);
      }
      return;
    }

    // Swap tile with the first adjacent empty tile
    const emptyPos = adjacentEmptyTiles[0];
    [tiles[index], tiles[emptyPos]] = [tiles[emptyPos], tiles[index]];

    // Update emptyIndices array
    const emptyIndexInArray = emptyIndices.indexOf(emptyPos);
    emptyIndices[emptyIndexInArray] = index;

    moveCount++;

    // Update UI
    renderBoard();
    moveCountEl.textContent = moveCount;

    // Check win
    if (checkWin()) {
      handleWin();
    }
  }

  // Render board
  function renderBoard() {
    // Determine which tile values are empty based on mode
    const emptyValues = mode === "easy"
      ? [totalTiles - 2, totalTiles - 1]
      : [totalTiles - 1];

    board.innerHTML = tiles
      .map((tileValue, index) => {
        const isEmpty = emptyValues.includes(tileValue);
        const row = Math.floor(tileValue / gridSize);
        const col = tileValue % gridSize;

        // Calculate background position for image tiles
        const bgPosX = (col / (gridSize - 1)) * 100;
        const bgPosY = (row / (gridSize - 1)) * 100;

        const imageUrl = config.puzzle.image
          ? `${import.meta.env.BASE_URL}${config.puzzle.image.replace(/^\//, "")}`
          : "";

        const imageStyle =
          !isEmpty && imageUrl
            ? `background-image: url('${imageUrl}');
               background-position: ${bgPosX}% ${bgPosY}%;
               background-size: ${gridSize * 100}%;`
            : "";

        return `
        <div
          class="puzzle__tile ${isEmpty ? "puzzle__tile--empty" : ""}"
          data-index="${index}"
          data-value="${tileValue}"
          style="${imageStyle}"
        >
          ${!isEmpty && !config.puzzle.image ? tileValue + 1 : ""}
        </div>
      `;
      })
      .join("");

    // Add click listeners
    board.querySelectorAll(".puzzle__tile").forEach((tile, index) => {
      tile.addEventListener("click", () => handleTileClick(index));
    });
  }

  // Handle win state
  function handleWin() {
    isWon = true;

    // Update win message with move count and mode
    const modeText = mode === "easy" ? "easy" : "hard";
    winSubtitleEl.textContent = `You solved it in ${moveCount} moves on ${modeText} mode!`;

    // Show win overlay with delay for last tile animation
    setTimeout(() => {
      winOverlay.hidden = false;
      winOverlay.classList.add("puzzle__win--show");
    }, 300);
  }

  // Reset game
  function resetGame() {
    tiles = shuffle(createSolvedState());

    // Initialize empty indices based on mode
    if (mode === "easy") {
      emptyIndices = [
        tiles.indexOf(totalTiles - 2),
        tiles.indexOf(totalTiles - 1)
      ];
    } else {
      emptyIndices = [tiles.indexOf(totalTiles - 1)];
    }

    moveCount = 0;
    isWon = false;

    moveCountEl.textContent = "0";
    winOverlay.hidden = true;
    winOverlay.classList.remove("puzzle__win--show");

    updateModeButtons();
    renderBoard();
  }

  // Update mode button active states
  function updateModeButtons() {
    modeButtons.forEach(btn => {
      if (btn.dataset.mode === mode) {
        btn.classList.add("puzzle__mode-btn--active");
      } else {
        btn.classList.remove("puzzle__mode-btn--active");
      }
    });
  }

  // Handle mode switch
  function handleModeSwitch(newMode) {
    if (mode === newMode) return;
    mode = newMode;
    resetGame();
  }

  // Initialize
  resetBtn.addEventListener("click", resetGame);
  modeButtons.forEach(btn => {
    btn.addEventListener("click", () => handleModeSwitch(btn.dataset.mode));
  });
  resetGame();
}
